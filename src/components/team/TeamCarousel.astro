---
import Icon from '@components/ui/Icon.astro';

interface Props {
    dragSpeed?: number;
    startIndex?: number;
}
const { dragSpeed, startIndex } = Astro.props;
---

<div is="team-carousel" class="group relative mt-16 md:mt-20 overflow-hidden w-screen py-16 px-4" data-dragspeed={dragSpeed} data-startindex={startIndex}>
    <button data-name="left" class="lg:opacity-0 group-hover:opacity-100 group absolute top-40 left-1/12 rounded-full border border-neutral-700 lg:backdrop-blur-sm hover:-translate-x-2 duration-500 px-3 py-5 sm:py-6 z-40">
        <Icon className="w-8 sm:w-12 h-auto stroke-[1.5] stroke-sky-400" name="left-arrow" />
    </button>
    <ul class="relative flex gap-4 transition-transform duration-300">
        <slot />
    </ul>
    <button data-name="right" class="lg:opacity-0 group-hover:opacity-100 group absolute top-40 right-1/12 rounded-full border border-neutral-700 lg:backdrop-blur-sm hover:translate-x-2 duration-500 px-3 py-5 sm:py-6 z-40">
        <Icon className="w-8 sm:w-12 h-auto stroke-[1.5] stroke-sky-400" name="right-arrow" />
    </button>
</div>

<script>
    import { debounce } from '@libs/utils';

    class TeamCarousel extends HTMLDivElement {
        startIndex: number = 0; // The index of the card that is in the center at the start
        currentIndex: number = 0; // The index of the card that is currently in the center
        cards: Array<HTMLLIElement>; // The cards in the carousel
        dragSpeed: number = 0.3; // The speed of the transition when dragging
        offset: number = 0; // The offset to center the cards
        gap: number = 0; // The gap between the cards in pixels
        carousel: HTMLUListElement; // The carousel element
        translation: number = 0; // The current translation of the carousel
        isDragging: boolean = false; // Whether the user is dragging the carousel
        startX: number = 0; // The x position of the mouse when the user starts dragging
        currentX: number = 0; // The current x position of the mouse when the user is dragging
        noClick: boolean = false; // Whether the user stop dragging the carousel


        constructor() {
            super();

            this.carousel = this.querySelector('ul')!;
            this.cards = Array.from(this.querySelectorAll('li'));
            this.dragSpeed = parseFloat(this.dataset.dragspeed ?? '0.3');
        }

        connectedCallback() {
            /// Initialize variables ///
            this.currentIndex = parseInt(this.dataset.startindex ?? '0'); // Set the current index to the start index given in the HTML
            this.gap = parseFloat(window.getComputedStyle(this.carousel).gap.replace('px', '')) || 0; // Get the gap between the cards
            /*
             * The offset is the distance that the cards need to be translated to center the cards.
             * The offset is calculated by taking the width of the carousel, dividing it by 2, and subtracting half of the width of a card and half of the gap.
             * 
             * Here is a visual representation of the offset (with startIndex=4):
             * 
             * +----------------------------The carousel---------------------------------+
             * |                                                                         |
             * |------------------------------------|: carousel width/2                  |
             * |                                |---|: (card width + gap)/2              |
             * |  +---+   +---+   +---+   +---+   +---+   +---+   +---+   +---+   +---+  |
             * |  | 0 |   | 1 |   | 2 |   | 3 |   | 4 |   | 5 |   | 6 |   | 7 |---| 8 |<-|--- a card
             * |  +---+   +---+   +---+   +---+   +---+   +---+   +---+   +---+ ^ +---+  |
             * |                                                                |        |
             * |--------------------------------|: offset                       +--------|--- the gap (the distance between the cards)
             * |                                                                         |
             * +-------------------------------------------------------------------------+
             */
            this.offset = this.carousel.getBoundingClientRect().width/2 - (this.cards[0].offsetWidth + this.gap)/2;

            /// Add event listeners ///
            // Add a click event listener to each card to move to that card when clicked
            this.cards.forEach((card, index) => {
                card.style.transitionDuration = `${this.dragSpeed}s`;
                card.addEventListener('click', () => {
                    if (this.noClick) {
                        this.noClick = false;
                        return;
                    }
                    this.updateCardPositions(index);
                });
            });

            // Add click event listeners to the left and right buttons to move to the previous or next card
            this.querySelector('[data-name="left"]')!.addEventListener('click', () => {
                this.updateCardPositions(this.currentIndex - 1);
            });
            this.querySelector('[data-name="right"]')!.addEventListener('click', () => {
                this.updateCardPositions(this.currentIndex + 1);
            });

            // Add keydown event listener to move to the previous or next card when the left or right arrow keys are pressed
            document.addEventListener('keydown', debounce(this.handleKeydown.bind(this), 100)); // Debounce the event listener to prevent spamming, events will be fired at most once every 100ms

            // Add mousedown event listener to start dragging the carousel
            this.carousel.addEventListener('mousedown', (event: MouseEvent) => {
                event.preventDefault();
                this.isDragging = true;
                this.startX = event.clientX;
                // Stop CSS animations
                this.carousel.classList.remove('duration-300');
                this.carousel.classList.add('duration-0');
                this.style.cursor = 'grabbing';
            });
            this.carousel.addEventListener('mousemove', this.handleDragging.bind(this));
            this.carousel.addEventListener('mouseup', this.handleMouseup.bind(this));

            // Update the offset when the window is resized
            window.addEventListener('resize', this.handleResize.bind(this));

            // Set the initial card positions
            this.updateCardPositions(this.currentIndex);
        }
        
        handleDragging(event: MouseEvent) {
            if (!this.isDragging) return;
            event.preventDefault();
            this.currentX = event.clientX;
            const diff = this.currentX - this.startX;
            this.translation += diff;
            this.carousel.style.transform = `translateX(${this.translation}px)`;
            this.startX = this.currentX;
        }

        handleKeydown(event: KeyboardEvent) {
            if (event.key === 'ArrowLeft') {
                this.updateCardPositions(this.currentIndex - 1);
            } else if (event.key === 'ArrowRight') {
                this.updateCardPositions(this.currentIndex + 1);
            }
        }

        handleMouseup() {
            this.isDragging = false;
            this.noClick = true;
            this.carousel.classList.remove('duration-0');
            this.carousel.classList.add('duration-300');
            this.style.cursor = 'grab';

            // Compute the index of the card that is currently nearest to the center
            const cardWidth = this.cards[0].offsetWidth;
            const diff = Math.round((this.offset - this.translation) / (cardWidth + this.gap));
            this.updateCardPositions(diff);
        }

        handleResize() {
            this.offset = this.carousel.getBoundingClientRect().width/2 - (this.cards[0].offsetWidth + this.gap)/2; // Calculate the offset to center the cards
            this.updateCardPositions(this.currentIndex);
        }

        updateCardPositions(target: number) {
            console.log(`Updating card positions to ${target}`);
            if (target < 0) {
                target = this.cards.length - 1; // Wrap to the last card when reaching the beginning
            } else if (target >= this.cards.length) {
                target = 0; // Wrap to the first card when reaching the end
            }
            
            const diff = this.startIndex - target;
            const cardWidth = this.cards[0].offsetWidth;

            this.cards[this.currentIndex].style.transform = 'scale(1)';
            this.translation = diff * (cardWidth + this.gap) + this.offset;
            this.carousel.style.transform = `translateX(${this.translation}px)`;
            this.cards[target].style.transform = 'scale(1.25)';
            this.currentIndex = target;
        }
    }

    customElements.define('team-carousel', TeamCarousel, {extends: 'div'});
</script>